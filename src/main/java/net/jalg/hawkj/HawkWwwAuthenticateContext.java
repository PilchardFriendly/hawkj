package net.jalg.hawkj;

import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

import net.jalg.hawkj.AuthorizationHeader.AuthorizationBuilder;
import net.jalg.hawkj.HawkContext.HawkContextBuilder_B;
import net.jalg.hawkj.WwwAuthenticateHeader.WwwAuthenticateBuilder;
import net.jalg.hawkj.util.Base64;

/**
 * FIXME update docs: HawkContext is an immutable class for working with Hawk
 * authentication data.
 * 
 * HawkContext instances contain
 * <ul>
 * <li>HTTP request data: method, path, host, and port.</li>
 * <li>Replay protection data: timestamp and nonce.</li>
 * <li>Credentials: id, key, and algorithm.</li>
 * <li>Payload hash: a hash of request or response payload.</li>
 * <li>Extension data: application specific extension data.</li>
 * </ul>
 * <p>
 * HawkContext instances are created using a fluent API that uses a set of
 * interfaces (HawkContextBuilder_A, HawkContextBuilder_B, HawkContextBuilder_C,
 * and {@link HawkWwwAuthenticateContextBuilder}) to guide the user through the
 * process of supplying the necessary data at each step. The process follows
 * these general steps:
 * <ol>
 * <li>Provide request data.</li>
 * <li>Provide credentials.</li>
 * <li>Optionally provide timestamp and nonce. If they are not provided, they
 * will be generated by the builder's {@link HawkContextBuilder.build()} method
 * when the target instance is created.</li>
 * <li>Optionally provide a payload and content type. If these are provided, the
 * builder will generate the hash value according to <a
 * href="https://github.com/hueniverse/hawk#payload-validation">Hawk</a> and add
 * the hash value to the target instance during building.</li>
 * <li>Optionally (and <b>alternatively</b> to payload and content type) provide
 * a payload hash value. This value will be copied to the target instance during
 * the building process.</li>
 * <li>Optionally supply application specific extension data.</li>
 * <li></li>
 * </ol>
 * Given an instance of the HawkContext class, the API is designed to enable
 * tasks such as
 * <ul>
 * <li>Create a (Server-)Authorization header value</li>
 * <li>Validate a received HMAC</li>
 * <li>Validate a received body hash</li>
 * <li>Pass request and credentials information from a request handling chain to
 * the associated response handling chain.</li>
 * <li>Clone the instance to create a new builder. (Useful for creating response
 * HawkContext instance from a request HawkContext instance for generating a
 * Server-Authorization response header)</li>
 * </ul>
 * 
 * @author Jan Algermissen, http://jalg.net
 * 
 */
public class HawkWwwAuthenticateContext {

	public static final String SCHEME = "Hawk";

	private static final String SLF = "\n"; // String-LineFeed

	private static final String HAWK_VERSION = "1";
	private static final String HAWK_TS_PREFIX = "hawk." + HAWK_VERSION + ".ts";

	private final int ts;
	private final String tsm;

	private final String id;
	private final String key;
	private final Algorithm algorithm;

	private HawkWwwAuthenticateContext() {
		this.ts = 0;
		this.tsm = null;
		this.id = null;
		this.key = null;
		this.algorithm = null;

	}

	private HawkWwwAuthenticateContext(int ts, String tsm, String id,
			String key, Algorithm algorithm) {
		this.ts = ts;
		this.tsm = tsm;
		this.id = id;
		this.key = key;
		this.algorithm = algorithm;

	}

	public int getTs() {
		return this.ts;
	}

	public String getId() {
		return this.id;
	}

	public String getKey() {
		return this.key;
	}

	public Algorithm getAlgorithm() {
		return this.algorithm;
	}

	public String getTsm() {
		return this.tsm;
	}

	public boolean hasTs() {
		return ts != 0;
	}
	public boolean hasTsm() {
		return tsm != null;
	}

	/**
	 * Create a WWW-Authenticate header from this HawkWwwAuthenticateContext.
	 * 
	 * FIXME The method returns a new AuthorizationHeader instance from the data
	 * in this HawkContext. For this the HMAC of the contained data is
	 * calculated and put into the header with the other parameters required bu
	 * the specification.
	 * 
	 * 
	 * @see net.jalg.hawkj.WwwAuthenticateHeader
	 * 
	 * @return The newly created header object.
	 * @throws HawkException
	 */
	public WwwAuthenticateHeader createWwwAuthenticateHeader()
			throws HawkException {

		WwwAuthenticateBuilder headerBuilder = WwwAuthenticateHeader
				.wwwAuthenticate();

		if (hasTs()) {
			if (!hasTsm()) {
				String hmac = this.generateHmac();
				headerBuilder.ts(getTs()).tsm(hmac);
			} else {
				headerBuilder.ts(getTs()).tsm(getTsm());

			}
		}

		return headerBuilder.build();
	}

	/**
	 * Check whether a given HMAC value matches the HMAC for this HawkContext.
	 * 
	 * @param hmac
	 *            The HMAC value to test.
	 * @return true if the HMAC matches the HMAC computed for this Jhawk, false
	 *         otherwise.
	 * @throws HawkException
	 */
	public boolean isValidMac(String hmac) throws HawkException {
		String this_hmac = this.generateHmac();
		return Util.fixedTimeEqual(this_hmac, hmac);
	}

	// FIXME: toString()

	/**
	 * Generate base string for HMAC generation.
	 * 
	 * @return
	 */
	private String getBaseString() {
		StringBuilder sb = new StringBuilder(HAWK_TS_PREFIX).append(SLF);
		sb.append(getTs()).append(SLF);
		return sb.toString();
	}

	/**
	 * Generate an HMAC from the HawkContext.
	 * 
	 * @return
	 * @throws HawkException
	 */
	private String generateHmac() throws HawkException {

		String baseString = getBaseString();

		Mac mac;
		try {
			mac = Mac.getInstance(getAlgorithm().getName());
		} catch (NoSuchAlgorithmException e) {
			throw new HawkException("Unknown algorithm "
					+ getAlgorithm().getName(), e);
		}

		SecretKeySpec secret_key = new SecretKeySpec(getKey().getBytes(
				StandardCharsets.UTF_8), getAlgorithm().getName());
		try {
			mac.init(secret_key);
		} catch (InvalidKeyException e) {
			throw new HawkException("Key is invalid ", e);
		}

		// String hmac = Util.bytesToHex( mac.doFinal(baseString
		// .getBytes(StandardCharsets.UTF_8)));

		String hmac = Base64.encodeBase64String(mac.doFinal(baseString
				.getBytes(StandardCharsets.UTF_8)));
		return hmac;
	}

	/**
	 * Create a new RequestBuilder_A, initialized with request data.
	 * 
	 * @param method
	 * @param path
	 * @param host
	 * @param port
	 * @return
	 */

	public static HawkWwwAuthenticateContextBuilder_A tsAndTsm(int ts,
			String tsm) {
		return new HawkWwwAuthenticateContextBuilder().ts(ts).tsm(tsm);
	}

	public static HawkWwwAuthenticateContextBuilder_A ts() {
		int now = (int) (System.currentTimeMillis() / 1000L);
		return new HawkWwwAuthenticateContextBuilder().ts(now);
	}

	public static interface HawkWwwAuthenticateContextBuilder_A {
		public HawkWwwAuthenticateContextBuilder credentials(String id,
				String key, Algorithm algorithm);
	}

	// public static interface HawkWwwAuthenticateContextBuilder_B {
	// public HawkContextBuilder_B credentials(String id, String key,
	// Algorithm algorithm);
	// }

	/**
	 * @author Jan Algermissen, http://jalg.net
	 * 
	 */
	public static class HawkWwwAuthenticateContextBuilder implements
			HawkWwwAuthenticateContextBuilder_A {

		private String id;
		private String key;
		private Algorithm algorithm;

		private int ts;
		private String tsm;

		private HawkWwwAuthenticateContextBuilder() {
		}

		private HawkWwwAuthenticateContextBuilder ts(int ts) {
			if (ts <= 0) {
				throw new IllegalArgumentException();
			}
			this.ts = ts;
			return this;
		}

		private HawkWwwAuthenticateContextBuilder tsm(String tsm) {
			if (tsm == null || tsm.length() == 0) {
				throw new IllegalArgumentException();
			}
			this.tsm = tsm;
			return this;
		}

		private HawkWwwAuthenticateContextBuilder id(String id) {
			if (id == null || id.length() == 0) {
				throw new IllegalArgumentException();
			}
			this.id = id;
			return this;
		}

		private HawkWwwAuthenticateContextBuilder key(String key) {
			if (key == null || key.length() == 0) {
				throw new IllegalArgumentException();
			}
			this.key = key;
			return this;
		}

		private HawkWwwAuthenticateContextBuilder algorithm(Algorithm algorithm) {
			if (algorithm == null) {
				throw new IllegalArgumentException();
			}
			this.algorithm = algorithm;
			return this;
		}

		public HawkWwwAuthenticateContextBuilder credentials(String id,
				String key, Algorithm algorithm) {
			return id(id).key(key).algorithm(algorithm);
		}

		public HawkWwwAuthenticateContext build() throws HawkException {

			if (this.ts != 0) {
				if (this.id == null || this.key == null
						|| this.algorithm == null) {
					throw new IllegalStateException();
				}

				return new HawkWwwAuthenticateContext(this.ts, this.tsm,
						this.id, this.key, this.algorithm);

			}

			return new HawkWwwAuthenticateContext();

			// if (this.ts == 0) {
			// ts = (int) (System.currentTimeMillis() / 1000);
			// } else {
			// ts = this.ts;
			// }
			//
			//
			// if (this.body != null && this.body.length > 0) {
			// if (this.tsm != null) {
			// throw new IllegalStateException(
			// "Cannot have body and hash, only either one");
			// }
			// hash = HawkWwwAuthenticateContextBuilder.generateHash(this.body,
			// this.contentType);
			// } else {
			// if (!(this.tsm == null || this.tsm.trim().equals(""))) {
			// hash = this.tsm;
			// }
			// }

		}

	}

}
